{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","useState","loaded","setLoaded","userTokens","setUserTokens","account","setAccount","token","setToken","tokenSale","setTokenSale","kycContract","setKycContract","kycCompleted","setKycCompleted","numberOfTokens","setNumberOfTokens","kycAdd","setKycAdd","kycRemove","setKycRemove","getContracts","a","Web3","detectEthereumProvider","web3","handleAccountsChanged","window","ethereum","request","method","eth","net","getId","networkId","Contract","MyToken","abi","networks","address","MyTokenSale","KycContract","alert","console","error","accounts","length","log","updateUserTokens","useCallback","methods","balanceOf","call","then","tokens","addKycWhitelisting","event","preventDefault","send","from","removeKycWhitelisting","setKycRevoked","handleBuyTokens","value","Math","max","parseInt","isNaN","buyTokens","useEffect","on","subscription","status","events","Transfer","to","unsubscribe","success","className","onSubmit","htmlFor","type","id","placeholder","onChange","e","target","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"ij0IAmKeA,G,MA1JH,WAAO,IAAD,EACYC,oBAAS,GADrB,mBACTC,EADS,KACDC,EADC,OAEoBF,mBAAS,GAF7B,mBAETG,EAFS,KAEGC,EAFH,OAGcJ,qBAHd,mBAGTK,EAHS,KAGAC,EAHA,OAIUN,qBAJV,mBAITO,EAJS,KAIFC,EAJE,OAKkBR,qBALlB,mBAKTS,EALS,KAKEC,EALF,OAMsBV,qBANtB,mBAMTW,EANS,KAMIC,EANJ,OAOwBZ,oBAAS,GAPjC,mBAOTa,EAPS,KAOKC,EAPL,OAQ4Bd,mBAAS,IARrC,mBAQTe,EARS,KAQOC,EARP,OASYhB,mBAAS,IATrB,mBASTiB,EATS,KASDC,EATC,OAUkBlB,mBAAS,IAV3B,mBAUTmB,EAVS,KAUEC,EAVF,KAYVC,EAAY,uCAAG,8BAAAC,EAAA,2EAEAC,IAFA,SAEWC,MAFX,0BAEXC,EAFW,oBAGjBC,EAHiB,SAGWC,OAAOC,SAASC,QAAQ,CAAEC,OAAQ,iBAH7C,mDAIOL,EAAKM,IAAIC,IAAIC,QAJpB,QAIXC,EAJW,OAKjB1B,EAAS,IAAIiB,EAAKM,IAAII,SAASC,EAAQC,IAAKD,EAAQE,SAASJ,IAAcE,EAAQE,SAASJ,GAAWK,UACvG7B,EAAa,IAAIe,EAAKM,IAAII,SAASK,EAAYH,IAAKG,EAAYF,SAASJ,IAAcM,EAAYF,SAASJ,GAAWK,UACvH3B,EAAe,IAAIa,EAAKM,IAAII,SAASM,EAAYJ,IAAKI,EAAYH,SAASJ,IAAcO,EAAYH,SAASJ,GAAWK,UAPxG,kDASjBG,MAAM,0EACNC,QAAQC,MAAR,MAViB,0DAAH,qDAcZlB,EAAwB,SAAAmB,GACJ,IAApBA,EAASC,OACXH,QAAQI,IAAI,+BAEZzC,EAAWuC,EAAS,KAIlBG,EAAmBC,uBAAY,WAE/B1C,GACFA,EAAM2C,QACHC,UAAU9C,GACV+C,OACAC,MAAK,SAAAC,GAAM,OAAIlD,EAAckD,QAEjC,CAACjD,EAASE,IAEPgD,EAAkB,uCAAG,WAAMC,GAAN,eAAAlC,EAAA,6DACzBkC,EAAMC,iBACAlB,EAAUtB,EAChBC,EAAU,kBAHe,kBAKjBP,EAAYuC,QAAQpC,gBAAgByB,GAASmB,KAAK,CAAEC,KAAMtD,IALzC,OAMvBqC,MAAMH,EAAU,gCANO,gDAQvBG,MAAM,mDACNC,QAAQI,IAAR,MATuB,QAWzB7B,EAAU,IAXe,yDAAH,sDAclB0C,GAAqB,uCAAG,WAAMJ,GAAN,eAAAlC,EAAA,6DAC5BkC,EAAMC,iBACAlB,EAAUpB,EAChBC,EAAa,kBAHe,kBAKpBT,EAAYuC,QAAQW,cAActB,GAASmB,KAAK,CAAEC,KAAMtD,IALpC,OAM1BqC,MAAMH,EAAU,oCANU,gDAQ1BG,MAAM,mDACNC,QAAQI,IAAR,MAT0B,QAW5B3B,EAAa,IAXe,yDAAH,sDAcrB0C,GAAe,uCAAG,WAAMN,GAAN,eAAAlC,EAAA,yDACtBkC,EAAMC,iBACAM,EAAQC,KAAKC,IAAIC,SAASnD,GAAiB,GACjDC,EAAkB,mBACdmD,MAAMJ,GAJY,gBAKpBrB,MAAM,+CALc,iDAQZjC,EAAUyC,QAAQkB,UAAU/D,GAASqD,KAAK,CAAEC,KAAMtD,EAAS0D,MAAOA,IARtD,0DAUlBrB,MAAM,gFACNC,QAAQI,IAAR,MAXkB,QActB/B,EAAkB,IAdI,0DAAH,sDA2CrB,OA1BAqD,qBAAU,WACRhD,IACAM,OAAOC,SAAS0C,GAAG,kBAAmB5C,GACtCxB,GAAU,KACT,IAEHmE,qBAAU,WACR,IAAIE,EAAe,KAUnB,OARI5D,GAAeJ,GAASF,IAC1BM,EAAYuC,QACTrC,aAAaR,GACb+C,OACAC,MAAK,SAAAmB,GAAM,OAAI1D,EAAgB0D,MAClCxB,IACAuB,EAAehE,EAAMkE,OAAOC,SAAS,CAAEC,GAAItE,IAAWiE,GAAG,QAAQ,kBAAMtB,QAElE,WACDuB,GACFA,EAAaK,aAAY,SAAChC,EAAOiC,GAC3BjC,GAAOD,QAAQI,IAAIH,SAI5B,CAACjC,EAAaJ,EAAOF,IAEnBJ,EAIH,yBAAK6E,UAAU,OACb,8DACA,qDACA,2BACE,uCADF,0DAGA,0CACA,8CACmBjE,EAAe,GAAK,MADvC,iBAC4DA,EAAe,sBAAwB,sCAEnG,kDAAwBV,EAAxB,iBACA,0BAAM2E,UAAU,eAAeC,SAAUjB,IACvC,2BAAOkB,QAAQ,aAAf,mEACA,6BACA,2BAAOC,KAAK,OAAOC,GAAG,YAAYnB,MAAOhD,EAAgBoE,YAAY,IAAIC,SAAU,SAAAC,GAAC,OAAIrE,EAAkBqE,EAAEC,OAAOvB,UACnH,4BAAQkB,KAAK,UAAb,eAEF,gDACA,2BACE,uCADF,iDAGA,0BAAMH,UAAU,eAAeC,SAAUxB,GACvC,2BAAOyB,QAAQ,cAAf,qBACA,2BAAOC,KAAK,OAAOC,GAAG,aAAanB,MAAO9C,EAAQkE,YAAY,WAAWC,SAAU,SAAAC,GAAC,OAAInE,EAAUmE,EAAEC,OAAOvB,UAC3G,4BAAQkB,KAAK,UAAb,qBAEF,0BAAMH,UAAU,eAAeC,SAAUnB,IACvC,2BAAOoB,QAAQ,cAAf,wBACA,2BAAOC,KAAK,OAAOC,GAAG,aAAanB,MAAO5C,EAAWgE,YAAY,WAAWC,SAAU,SAAAC,GAAC,OAAIjE,EAAaiE,EAAEC,OAAOvB,UACjH,4BAAQkB,KAAK,UAAb,2BAhCG,0ECjHSM,QACW,cAA7B5D,OAAO6D,SAASC,UAEe,UAA7B9D,OAAO6D,SAASC,UAEhB9D,OAAO6D,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM5C,MAAK,SAAA6C,GACjCA,EAAaC,kB","file":"static/js/main.57ed72ed.chunk.js","sourcesContent":["import React, { useState, useEffect, useCallback } from 'react'\nimport MyToken from './contracts/MyToken.json'\nimport MyTokenSale from './contracts/MyTokenSale.json'\nimport KycContract from './contracts/KycContract.json'\nimport Web3 from 'web3'\nimport detectEthereumProvider from '@metamask/detect-provider'\n\nimport './App.css'\n\nconst App = () => {\n  const [loaded, setLoaded] = useState(false)\n  const [userTokens, setUserTokens] = useState(0)\n  const [account, setAccount] = useState()\n  const [token, setToken] = useState()\n  const [tokenSale, setTokenSale] = useState()\n  const [kycContract, setKycContract] = useState()\n  const [kycCompleted, setKycCompleted] = useState(false)\n  const [numberOfTokens, setNumberOfTokens] = useState('')\n  const [kycAdd, setKycAdd] = useState('')\n  const [kycRemove, setKycRemove] = useState('')\n\n  const getContracts = async () => {\n    try {\n      const web3 = new Web3(await detectEthereumProvider())\n      handleAccountsChanged(await window.ethereum.request({ method: 'eth_accounts' }))\n      const networkId = await web3.eth.net.getId()\n      setToken(new web3.eth.Contract(MyToken.abi, MyToken.networks[networkId] && MyToken.networks[networkId].address))\n      setTokenSale(new web3.eth.Contract(MyTokenSale.abi, MyTokenSale.networks[networkId] && MyTokenSale.networks[networkId].address))\n      setKycContract(new web3.eth.Contract(KycContract.abi, KycContract.networks[networkId] && KycContract.networks[networkId].address))\n    } catch (error) {\n      alert(`Failed to load web3, accounts, or contract. Check console for details.`)\n      console.error(error)\n    }\n  }\n\n  const handleAccountsChanged = accounts => {\n    if (accounts.length === 0) {\n      console.log('Please connect to MetaMask.')\n    } else {\n      setAccount(accounts[0])\n    }\n  }\n\n  const updateUserTokens = useCallback(() => {\n    // As 'token' is initiated as 'undefined' we need a conditional to prevent errors\n    if (token) {\n      token.methods\n        .balanceOf(account)\n        .call()\n        .then(tokens => setUserTokens(tokens))\n    }\n  }, [account, token])\n\n  const addKycWhitelisting = async event => {\n    event.preventDefault()\n    const address = kycAdd\n    setKycAdd('Please wait...')\n    try {\n      await kycContract.methods.setKycCompleted(address).send({ from: account })\n      alert(address + ' was added to the whitelist.')\n    } catch (error) {\n      alert('Transaction failed: Are you the contract owner?')\n      console.log(error)\n    }\n    setKycAdd('')\n  }\n\n  const removeKycWhitelisting = async event => {\n    event.preventDefault()\n    const address = kycRemove\n    setKycRemove('Please wait...')\n    try {\n      await kycContract.methods.setKycRevoked(address).send({ from: account })\n      alert(address + ' was removed from the whitelist.')\n    } catch (error) {\n      alert('Transaction failed: Are you the contract owner?')\n      console.log(error)\n    }\n    setKycRemove('')\n  }\n\n  const handleBuyTokens = async event => {\n    event.preventDefault()\n    const value = Math.max(parseInt(numberOfTokens), 0)\n    setNumberOfTokens('Please wait...')\n    if (isNaN(value)) {\n      alert('Please enter a natural number like 4 or 12!')\n    } else {\n      try {\n        await tokenSale.methods.buyTokens(account).send({ from: account, value: value })\n      } catch (error) {\n        alert('Transaction failed: Please ask the contract owner to whitelist your account!')\n        console.log(error)\n      }\n    }\n    setNumberOfTokens('')\n  }\n\n  useEffect(() => {\n    getContracts()\n    window.ethereum.on('accountsChanged', handleAccountsChanged)\n    setLoaded(true)\n  }, [])\n\n  useEffect(() => {\n    let subscription = null\n    // As 'kycContract', 'token' and 'account' are initiated as 'undefined' we need a conditional to prevent errors\n    if (kycContract && token && account) {\n      kycContract.methods\n        .kycCompleted(account)\n        .call()\n        .then(status => setKycCompleted(status))\n      updateUserTokens()\n      subscription = token.events.Transfer({ to: account }).on('data', () => updateUserTokens())\n    }\n    return () => {\n      if (subscription) {\n        subscription.unsubscribe((error, success) => {\n          if (error) console.log(error)\n        })\n      }\n    }\n  }, [kycContract, token, account])\n\n  if (!loaded) {\n    return <div>Loading Web3, accounts, and contract...</div>\n  }\n  return (\n    <div className='App'>\n      <h1>StarDucks Cappucino Token Sale</h1>\n      <p>Get your Tokens today!</p>\n      <p>\n        <span>Note:</span> You need to be connected to the Ropsten test network.\n      </p>\n      <h2>Buy Tokens</h2>\n      <p>\n        Your account is {kycCompleted ? '' : 'not'} whitelisted. {kycCompleted ? 'You can buy tokens.' : 'Please contact the contract owner!'}\n      </p>\n      <p>You currently have: {userTokens} CAPPU Tokens</p>\n      <form className='form-control' onSubmit={handleBuyTokens}>\n        <label htmlFor='buyTokens'>How many tokens would you like to buy? One token costs one Wei.</label>\n        <br></br>\n        <input type='text' id='buyTokens' value={numberOfTokens} placeholder='0' onChange={e => setNumberOfTokens(e.target.value)} />\n        <button type='submit'>Buy Tokens</button>\n      </form>\n      <h2>Kyc Whitelisting</h2>\n      <p>\n        <span>Note:</span> This can only be done by the contract owner!\n      </p>\n      <form className='form-control' onSubmit={addKycWhitelisting}>\n        <label htmlFor='kycAddress'>Address to allow:</label>\n        <input type='text' id='kycAddress' value={kycAdd} placeholder='0x123...' onChange={e => setKycAdd(e.target.value)} />\n        <button type='submit'>Add to Whitelist</button>\n      </form>\n      <form className='form-control' onSubmit={removeKycWhitelisting}>\n        <label htmlFor='kycAddress'>Address to disallow:</label>\n        <input type='text' id='kycAddress' value={kycRemove} placeholder='0x123...' onChange={e => setKycRemove(e.target.value)} />\n        <button type='submit'>Remove from Whitelist</button>\n      </form>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}